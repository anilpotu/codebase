pipeline {
    agent {
        kubernetes {
            yaml '''
apiVersion: v1
kind: Pod
metadata:
  labels:
    jenkins: agent
spec:
  containers:
    - name: maven
      image: maven:3.8-openjdk-8
      command: ['sleep']
      args: ['infinity']
      volumeMounts:
        - name: maven-cache
          mountPath: /root/.m2/repository
    - name: docker
      image: docker:24-dind
      securityContext:
        privileged: true
      volumeMounts:
        - name: docker-sock
          mountPath: /var/run/docker.sock
    - name: kubectl
      image: bitnami/kubectl:1.28
      command: ['sleep']
      args: ['infinity']
    - name: aws-cli
      image: amazon/aws-cli:2.15.0
      command: ['sleep']
      args: ['infinity']
  volumes:
    - name: maven-cache
      persistentVolumeClaim:
        claimName: maven-repo-cache
    - name: docker-sock
      hostPath:
        path: /var/run/docker.sock
'''
        }
    }

    parameters {
        choice(name: 'DEPLOY_ENV', choices: ['dev', 'staging', 'prod'], description: 'Target deployment environment')
        string(name: 'SERVICES', defaultValue: 'all', description: 'Comma-separated service names to deploy, or "all"')
        booleanParam(name: 'SKIP_TESTS', defaultValue: false, description: 'Skip unit tests during build')
        string(name: 'DOCKER_TAG', defaultValue: '', description: 'Docker image tag (defaults to BUILD_NUMBER)')
    }

    environment {
        AWS_REGION        = 'us-east-1'
        K8S_NAMESPACE     = 'secure-distributed'
        PROJECT_VERSION   = '1.0.0'
        IMAGE_TAG         = "${params.DOCKER_TAG ?: env.BUILD_NUMBER}"
        MAVEN_OPTS        = '-Xmx1024m -XX:MaxPermSize=256m'

        // Service definitions
        ALL_SERVICES = 'config-server,eureka-server,api-gateway,auth-service,user-service,order-service,product-service'

        // Credentials
        AWS_CREDENTIALS   = credentials('aws-credentials')
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '20'))
        timestamps()
        timeout(time: 60, unit: 'MINUTES')
        disableConcurrentBuilds()
        ansiColor('xterm')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    env.GIT_BRANCH_NAME  = sh(script: 'git rev-parse --abbrev-ref HEAD', returnStdout: true).trim()
                    env.DEPLOY_SERVICES  = (params.SERVICES == 'all') ? env.ALL_SERVICES : params.SERVICES

                    echo "Branch: ${env.GIT_BRANCH_NAME}"
                    echo "Commit: ${env.GIT_COMMIT_SHORT}"
                    echo "Tag:    ${env.IMAGE_TAG}"
                    echo "Env:    ${params.DEPLOY_ENV}"
                    echo "Services: ${env.DEPLOY_SERVICES}"
                }
            }
        }

        stage('Build') {
            steps {
                container('maven') {
                    sh """
                        mvn clean package \
                            ${params.SKIP_TESTS ? '-DskipTests' : ''} \
                            -B -q \
                            -Dmaven.test.failure.ignore=false
                    """
                }
            }
        }

        stage('Unit Tests') {
            when {
                expression { return !params.SKIP_TESTS }
            }
            steps {
                container('maven') {
                    sh 'mvn test -B'
                }
            }
            post {
                always {
                    junit(
                        testResults: '**/target/surefire-reports/*.xml',
                        allowEmptyResults: true
                    )
                    jacoco(
                        execPattern: '**/target/jacoco.exec',
                        classPattern: '**/target/classes',
                        sourcePattern: '**/src/main/java',
                        exclusionPattern: '**/dto/**,**/entity/**,**/config/**'
                    )
                }
            }
        }

        stage('Code Quality') {
            when {
                expression {
                    return env.SONARQUBE_ENABLED == 'true'
                }
            }
            steps {
                container('maven') {
                    withSonarQubeEnv('sonarqube') {
                        sh 'mvn sonar:sonar -B'
                    }
                }
            }
        }

        stage('Security Scan') {
            when {
                expression { return params.DEPLOY_ENV == 'prod' }
            }
            steps {
                container('maven') {
                    sh 'mvn org.owasp:dependency-check-maven:check -B -DfailBuildOnCVSS=9'
                }
            }
            post {
                always {
                    dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
                }
            }
        }

        stage('Build Docker Images') {
            steps {
                container('docker') {
                    script {
                        def services = env.DEPLOY_SERVICES.split(',')
                        def parallelBuilds = [:]

                        for (svc in services) {
                            def serviceName = svc.trim()
                            parallelBuilds["Build ${serviceName}"] = {
                                sh """
                                    docker build \
                                        -t secure-distributed/${serviceName}:${env.IMAGE_TAG} \
                                        -t secure-distributed/${serviceName}:latest \
                                        -f ${serviceName}/Dockerfile \
                                        ${serviceName}/
                                """
                            }
                        }

                        parallel parallelBuilds
                    }
                }
            }
        }

        stage('Push to ECR') {
            steps {
                container('aws-cli') {
                    script {
                        // Get AWS Account ID
                        env.AWS_ACCOUNT_ID = sh(
                            script: 'aws sts get-caller-identity --query Account --output text',
                            returnStdout: true
                        ).trim()
                        env.ECR_REGISTRY = "${env.AWS_ACCOUNT_ID}.dkr.ecr.${env.AWS_REGION}.amazonaws.com"
                    }
                }
                container('docker') {
                    script {
                        // Login to ECR
                        sh """
                            aws ecr get-login-password --region ${env.AWS_REGION} | \
                            docker login --username AWS --password-stdin ${env.ECR_REGISTRY}
                        """

                        def services = env.DEPLOY_SERVICES.split(',')
                        for (svc in services) {
                            def serviceName = svc.trim()
                            def ecrRepo = "${env.ECR_REGISTRY}/secure-distributed/${serviceName}"

                            sh """
                                docker tag secure-distributed/${serviceName}:${env.IMAGE_TAG} ${ecrRepo}:${env.IMAGE_TAG}
                                docker tag secure-distributed/${serviceName}:latest ${ecrRepo}:latest
                                docker push ${ecrRepo}:${env.IMAGE_TAG}
                                docker push ${ecrRepo}:latest
                            """
                        }
                    }
                }
            }
        }

        stage('Production Approval') {
            when {
                expression { return params.DEPLOY_ENV == 'prod' }
            }
            steps {
                input(
                    message: "Deploy to PRODUCTION?",
                    ok: 'Deploy',
                    submitter: 'admin,devops',
                    parameters: [
                        string(name: 'APPROVAL_NOTE', defaultValue: '', description: 'Approval notes')
                    ]
                )
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                container('kubectl') {
                    withCredentials([file(credentialsId: "kubeconfig-${params.DEPLOY_ENV}", variable: 'KUBECONFIG')]) {
                        script {
                            def services = env.DEPLOY_SERVICES.split(',')
                            def ecrPrefix = "${env.ECR_REGISTRY}/secure-distributed"

                            // Update image tags in manifests
                            for (svc in services) {
                                def serviceName = svc.trim()
                                sh """
                                    sed -i 's|image: secure-distributed/${serviceName}:.*|image: ${ecrPrefix}/${serviceName}:${env.IMAGE_TAG}|g' \
                                        k8s/${serviceName}.yaml
                                """
                            }

                            // Step 1: Namespace + Secrets + Redis
                            echo '--- Deploying namespace, secrets, and redis ---'
                            sh """
                                kubectl apply -f k8s/namespace.yaml
                                kubectl apply -f k8s/secrets.yaml
                                kubectl apply -f k8s/redis.yaml
                            """

                            // Step 2: Config Server
                            if (services.contains('config-server') || params.SERVICES == 'all') {
                                echo '--- Deploying config-server ---'
                                sh """
                                    kubectl apply -f k8s/config-server.yaml
                                    kubectl -n ${env.K8S_NAMESPACE} rollout status deployment/config-server --timeout=180s
                                """
                            }

                            // Step 3: Eureka Server
                            if (services.contains('eureka-server') || params.SERVICES == 'all') {
                                echo '--- Deploying eureka-server ---'
                                sh """
                                    kubectl apply -f k8s/eureka-server.yaml
                                    kubectl -n ${env.K8S_NAMESPACE} rollout status deployment/eureka-server --timeout=180s
                                """
                            }

                            // Step 4: Business services (can deploy in parallel)
                            def businessServices = ['api-gateway', 'auth-service', 'user-service', 'order-service', 'product-service']
                            def deployTargets = businessServices.findAll { svc ->
                                services.collect { it.trim() }.contains(svc)
                            }

                            if (deployTargets) {
                                echo "--- Deploying business services: ${deployTargets.join(', ')} ---"
                                for (svc in deployTargets) {
                                    sh "kubectl apply -f k8s/${svc}.yaml"
                                }
                            }

                            // Step 5: Apply Istio configuration
                            echo '--- Applying Istio configuration ---'
                            sh 'kubectl apply -f k8s/istio/'
                        }
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                container('kubectl') {
                    withCredentials([file(credentialsId: "kubeconfig-${params.DEPLOY_ENV}", variable: 'KUBECONFIG')]) {
                        script {
                            def services = env.DEPLOY_SERVICES.split(',')

                            for (svc in services) {
                                def serviceName = svc.trim()
                                echo "--- Verifying ${serviceName} ---"
                                sh """
                                    kubectl -n ${env.K8S_NAMESPACE} rollout status deployment/${serviceName} --timeout=300s
                                """
                            }

                            // Show deployment status
                            sh """
                                echo '=== Pod Status ==='
                                kubectl -n ${env.K8S_NAMESPACE} get pods -o wide
                                echo ''
                                echo '=== Service Status ==='
                                kubectl -n ${env.K8S_NAMESPACE} get svc
                                echo ''
                                echo '=== Deployment Status ==='
                                kubectl -n ${env.K8S_NAMESPACE} get deployments
                            """
                        }
                    }
                }
            }
        }

        stage('Integration Tests') {
            steps {
                container('kubectl') {
                    withCredentials([file(credentialsId: "kubeconfig-${params.DEPLOY_ENV}", variable: 'KUBECONFIG')]) {
                        script {
                            def healthChecks = [
                                'config-server:8888',
                                'eureka-server:8761',
                                'api-gateway:8000',
                                'auth-service:8080',
                                'user-service:8081',
                                'order-service:8082',
                                'product-service:8083'
                            ]

                            echo '=== Running Health Checks ==='
                            for (check in healthChecks) {
                                def parts = check.split(':')
                                def svcName = parts[0]
                                def svcPort = parts[1]

                                def status = sh(
                                    script: """
                                        kubectl -n ${env.K8S_NAMESPACE} exec deploy/${svcName} -- \
                                            wget -qO- --timeout=10 http://localhost:${svcPort}/actuator/health 2>/dev/null || echo 'UNREACHABLE'
                                    """,
                                    returnStdout: true
                                ).trim()

                                if (status.contains('"status":"UP"')) {
                                    echo "${svcName}: HEALTHY"
                                } else {
                                    echo "${svcName}: ${status}"
                                    unstable("${svcName} health check did not return UP")
                                }
                            }

                            // Test API Gateway routing
                            echo '=== Testing API Gateway Routes ==='
                            def gatewayRoutes = ['/api/auth', '/api/users', '/api/orders', '/api/products']
                            for (route in gatewayRoutes) {
                                sh """
                                    kubectl -n ${env.K8S_NAMESPACE} exec deploy/api-gateway -- \
                                        wget -qO- --timeout=10 http://localhost:8000/actuator/health 2>/dev/null || true
                                """
                            }
                        }
                    }
                }
            }
        }

        stage('Cleanup') {
            steps {
                container('docker') {
                    script {
                        def services = env.DEPLOY_SERVICES.split(',')
                        for (svc in services) {
                            def serviceName = svc.trim()
                            sh """
                                docker rmi secure-distributed/${serviceName}:${env.IMAGE_TAG} || true
                                docker rmi secure-distributed/${serviceName}:latest || true
                                docker rmi ${env.ECR_REGISTRY}/secure-distributed/${serviceName}:${env.IMAGE_TAG} || true
                                docker rmi ${env.ECR_REGISTRY}/secure-distributed/${serviceName}:latest || true
                            """
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            archiveArtifacts(
                artifacts: '**/target/*.jar',
                fingerprint: true,
                allowEmptyArchive: true
            )
            cleanWs()
        }
        success {
            echo """
                ============================================
                 DEPLOYMENT SUCCESSFUL
                 Environment: ${params.DEPLOY_ENV}
                 Services:    ${env.DEPLOY_SERVICES}
                 Image Tag:   ${env.IMAGE_TAG}
                 Commit:      ${env.GIT_COMMIT_SHORT}
                ============================================
            """
            // Uncomment to enable Slack notifications:
            // slackSend(
            //     color: 'good',
            //     channel: '#deployments',
            //     message: "SUCCESS: secure-distributed-system deployed to ${params.DEPLOY_ENV} (tag: ${env.IMAGE_TAG})"
            // )
        }
        failure {
            echo """
                ============================================
                 DEPLOYMENT FAILED
                 Environment: ${params.DEPLOY_ENV}
                 Services:    ${env.DEPLOY_SERVICES}
                 Image Tag:   ${env.IMAGE_TAG}
                 Commit:      ${env.GIT_COMMIT_SHORT}
                ============================================
            """
            // Uncomment to enable Slack notifications:
            // slackSend(
            //     color: 'danger',
            //     channel: '#deployments',
            //     message: "FAILED: secure-distributed-system deployment to ${params.DEPLOY_ENV} (tag: ${env.IMAGE_TAG})"
            // )
        }
    }
}
